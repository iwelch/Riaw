ng which columns
#' are undefined. This catches typos and misspellings early.
#' #'
#' #' To replace the base version globally, use:
#' #' \preformatted{
#' #' ns <- getNamespace("base")
#' #' unlockBinding("subset.data.frame", ns)
#' #' assign("subset.data.frame", iaw$subset.data.frame, envir = ns)
#' #' lockBinding("subset.data.frame", ns)
#' #' }
#' #'
#' #' Or use \code{trace()} for a non-invasive hook.
#' #'
#' #' @family data-manipulation
#' #' @export
#' #'
#' #' @examples
#' #' d <- data.frame(a = 1:5, b = 6:10, c = 11:15)
#' #'
#' #' # Valid selections work as expected
#' #' iaw$subset.data.frame(d, a > 2, select = c("a", "b"))
#' #' iaw$subset.data.frame(d, a > 2, select = c(a, b))
#' #'
#' #' # Invalid columns give informative errors
#' #' \dontrun{
#' #' iaw$subset.data.frame(d, TRUE, select = c("a", "typo"))
#' #' # Error: in `[.data.frame`(x, r, vars, drop = drop) :
#' #' #   undefined columns in 'select': typo
#' #'
#' #' iaw$subset.data.frame(d, TRUE, select = c(a, typo))
#' #' # Error: in `[.data.frame`(x, r, vars, drop = drop) :
#' #' #   undefined columns in 'select': typo
#' #' }
#' 
iaw$subset.data.frame <- function (x, subset, select, drop = FALSE, ...)
{
  chkDots(...)

  ## ---- row subset ----
  r <- if (missing(subset)) {
    rep_len(TRUE, nrow(x))
  } else {
    e <- substitute(subset)
    r <- eval(e, x, parent.frame())
    if (!is.logical(r))
      stop("'subset' must be logical", call. = FALSE)
    r & !is.na(r)
  }

  ## ---- column subset ----
  vars <- if (missing(select)) {
    rep_len(TRUE, ncol(x))
  } else {
    sel_expr <- substitute(select)

    ## evaluate once in caller to detect character selection
    sel_val <- try(eval(sel_expr, parent.frame()), silent = TRUE)

    if (is.character(sel_val)) {
      ## character selection: c("a", "yz")
      missing_vars <- setdiff(sel_val, names(x))
      if (length(missing_vars)) {
        stop(
            "in `[.data.frame`(x, r, vars, drop = drop) :\n  ",
          "undefined columns in 'select': ",
          paste(missing_vars, collapse = ", "),
          call. = FALSE
        )
      }
      sel_val
    } else {
      ## NSE selection: c(a, c), a:c, etc.
      sel_vars <- all.vars(sel_expr)
      missing_vars <- setdiff(sel_vars, names(x))

      if (length(missing_vars)) {
        stop(
            "in `[.data.frame`(x, r, vars, drop = drop) :\n  ",
          "undefined columns in 'select': ",
          paste(missing_vars, collapse = ", "),
          call. = FALSE
        )
      }

      nl <- as.list(seq_along(x))
      names(nl) <- names(x)
      eval(sel_expr, nl, parent.frame())
    }
  }

  x[r, vars, drop = drop]
}
