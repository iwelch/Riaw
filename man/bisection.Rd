% Generated by tools/generate-man.R -- do not edit by hand
\name{bisection}
\alias{bisection}
\title{Bisection Root Finding (Vectorized)}
\description{
Finds roots using bisection method. Supports vectorized inputs.
}
\usage{
bisection(f, lower, upper, ..., numiter = 100, tolerance = .Machine$double.eps^0.25, verbose = 0)
}
\arguments{
  \item{f}{Function to find root of.}
  \item{lower}{Numeric vector of lower bounds.}
  \item{upper}{Numeric vector of upper bounds.}
  \item{...}{Additional arguments passed to f.}
  \item{numiter}{Maximum iterations. Default 100.}
  \item{tolerance}{Convergence tolerance. Default .Machine$double.eps^0.25.}
  \item{verbose}{Print progress. Default 0. }
}
\value{
List with mid, fmid, lower, upper, flower, fupper, n. 
}
\seealso{

Other utilities: \code{\link{ascii}}, \code{\link{base}}, \code{\link{beep}}, \code{\link{cat.both}}, \code{\link{cat.stderr}}, \code{\link{chatter}}, \code{\link{check.names}}, \code{\link{debug.advice}}, \code{\link{debug.on}}, \code{\link{dict.lookup}}, \code{\link{done}}, \code{\link{enable.error.line.num}}, \code{\link{exit}}, \code{\link{grepcolname}}, \code{\link{heartbeat}}, \code{\link{index.of.variable}}, \code{\link{instrumentR}}, \code{\link{kable}}, \code{\link{latex}}, \code{\link{latlon.distance}}, \code{\link{latlonx}}, \code{\link{mklatlonid}}, \code{\link{invlatlon}}, \code{\link{testlatlon}}, \code{\link{ls.objects}}, \code{\link{meminfo}}, \code{\link{mk.random.walk}}, \code{\link{mkRdictionary}}, \code{\link{msg}}, \code{\link{nearest}}, \code{\link{now}}, \code{\link{numobs.by}}, \code{\link{object.size.MB}}, \code{\link{osinfo}}, \code{\link{rdraw.perfect}}, \code{\link{require.variables}}, \code{\link{rexp.perfect}}, \code{\link{rnorm.perfect}}, \code{\link{runall}}, \code{\link{setupknitr}}, \code{\link{sink}}, \code{\link{sprint.data.frame}}, \code{\link{strcat}}, \code{\link{whatis}}, \code{\link{which.nearest}}
}
\examples{
\dontrun{
# Find sqrt(2): solve x^2 - 2 = 0 on [0, 2]
res <- iaw$bisection(function(x) x^2 - 2, 0, 2)
res$mid   # approx 1.414214

# Solve a transcendental equation: e^x = 3
res2 <- iaw$bisection(function(x) exp(x) - 3, 0, 2)
res2$mid  # approx log(3) = 1.098612

# Vectorized: find roots for multiple targets simultaneously
targets <- c(2, 3, 4)
res3 <- iaw$bisection(function(x, t) x^2 - t,
                       lower = c(0, 0, 0), upper = c(2, 2, 2),
                       t = targets)
res3$mid  # approx sqrt(2), sqrt(3), sqrt(4)

# Find the implied volatility that prices a call at $5
# Black-Scholes vega search: C(sigma) - 5 = 0
bs_call <- function(sigma) {
  d1 <- (log(100/100) + (0.05 + sigma^2/2)) / sigma
  d2 <- d1 - sigma
  100 * pnorm(d1) - 100 * exp(-0.05) * pnorm(d2) - 5
}
iv <- iaw$bisection(bs_call, lower = 0.01, upper = 2.0)
iv$mid   # implied volatility solving C(sigma) = 5

# Find the break-even growth rate: PV of cashflows = initial investment
pv_func <- function(g) {
  cf <- 10 * (1 + g)^(1:10)
  sum(cf / (1.08)^(1:10)) - 80
}
be <- iaw$bisection(pv_func, lower = -0.05, upper = 0.20)
be$mid   # break-even growth rate

# Check convergence: number of iterations used
res <- iaw$bisection(function(x) x^3 - 1, 0, 2)
res$n    # iterations needed to converge
}
}
