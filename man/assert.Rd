% Generated by tools/generate-man.R -- do not edit by hand
\name{assert}
\alias{assert}
\title{Assert Condition}
\description{
Checks a condition and aborts with an error message if FALSE.
}
\usage{
assert(cond, ...)
}
\arguments{
  \item{cond}{Logical scalar to test.}
  \item{...}{Error message arguments passed to abort(). }
}
\value{
Invisible NULL if condition is TRUE; otherwise stops. 
}
\seealso{

Other error-handling: \code{\link{abort}}
}
\examples{
# Basic assertion that passes silently
iaw$assert(1 + 1 == 2, "math is broken")

# Glue-style interpolation in the message
n <- 5
iaw$assert(n > 0, paste("n must be positive, got", n))

# Common pattern: validate function arguments
\dontrun{
check_input <- function(x) {
  iaw$assert(is.numeric(x), paste("x must be numeric, got", class(x)))
  iaw$assert(length(x) > 0, "x must not be empty")
}
check_input(c(1, 2, 3))  # passes
check_input("oops")      # aborts with message
}

# Validate portfolio weights sum to 1
weights <- c(0.4, 0.35, 0.25)
iaw$assert(abs(sum(weights) - 1) < 1e-10, "weights must sum to 1")  # passes

# Assert catches the failure and returns a clean error via tryCatch
err <- tryCatch(
  iaw$assert(FALSE, "expected positive returns"),
  error = function(e) e$message
)
err   # "expected positive returns"

# Guard data dimensions before matrix operations
m <- matrix(1:12, nrow = 3)
iaw$assert(nrow(m) >= 2, paste("need >= 2 rows, got", nrow(m)))  # passes
}
