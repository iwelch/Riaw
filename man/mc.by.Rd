% Generated by tools/generate-man.R -- do not edit by hand
\name{mc.by}
\alias{mc.by}
\alias{mc.by.cache}
\alias{mc.by.cripple.toggle}
\alias{mc.by.data.frame}
\title{Parallel Apply by Groups}
\description{
Parallel version of by() using mclapply.
}
\usage{
mc.by(indata, INDICES, FUNIN, ...)
mc.by.cache(true.or.null)
mc.by.cripple.toggle()
mc.by.data.frame(indata, INDICES, FUN, ..., simplify = TRUE)
}
\arguments{
  \item{indata}{Data frame to process.}
  \item{INDICES}{Factor or list of factors for grouping.}
  \item{FUNIN}{Function to apply to each group.}
  \item{...}{Additional arguments to FUNIN. }
  \item{true.or.null}{Logical or \code{NULL}. Enable/disable the group split cache. }
  \item{FUN}{Function to apply (for \code{mc.by.data.frame}).}
  \item{simplify}{Logical. Simplify result (default \code{TRUE}). }
}
\value{
List of results. 
}
\details{
\code{mc.by.cripple.toggle} switches between parallel and serial execution.


\code{mc.by.data.frame} is a single-core variant using \code{tapply}.

}
\seealso{

Other parallel: \code{\link{mc.replicate}}, \code{\link{mclapply}}, \code{\link{mcsapply}}, \code{\link{oc.by}}, \code{\link{rbind.mc.by}}, \code{\link{rbind.oc.by}}
}
\examples{
# Compute group means in parallel
df <- data.frame(
  group = c("A", "A", "B", "B", "C"),
  value = c(1, 3, 2, 4, 5)
)
result <- iaw$mc.by(df, df$group, function(d) mean(d$value))
unlist(result)  # named vector: A=2, B=3, C=5

# Return a summary data frame per group (results are a list of data frames)
result <- iaw$mc.by(df, df$group, function(d) {
  data.frame(n = nrow(d), mean = mean(d$value), sd = sd(d$value))
})
do.call(rbind, result)

\dontrun{
# Toggle parallel off for debugging (runs serially via lapply)
iaw$mc.by.cripple.toggle()
result <- iaw$mc.by(df, df$group, function(d) mean(d$value))
iaw$mc.by.cripple.toggle()  # toggle back on
}
}
