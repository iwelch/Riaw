% Generated by tools/generate-man.R -- do not edit by hand
\name{mclapply}
\alias{mclapply}
\title{Enhanced Multicore Lapply}
\description{
Wrapper for parallel::mclapply with error handling.
}
\usage{
mclapply(X, FUN, ..., mc.cores = getOption("mc.cores", parallel::detectCores()), stop.on.error = TRUE, verbose = TRUE)
}
\arguments{
  \item{X}{List or vector.}
  \item{FUN}{Function to apply.}
  \item{...}{Arguments to FUN.}
  \item{mc.cores}{Number of cores.}
  \item{stop.on.error}{If TRUE, stop all workers on first error. Default TRUE.}
  \item{verbose}{Logical. Print error details on failure (default \code{TRUE}). }
}
\value{
List of results. 
}
\seealso{

Other parallel: \code{\link{mc.by}}, \code{\link{mc.replicate}}, \code{\link{mcsapply}}, \code{\link{oc.by}}, \code{\link{rbind.mc.by}}, \code{\link{rbind.oc.by}}
}
\examples{
\dontrun{
# Square numbers in parallel
iaw$mclapply(1:10, function(x) x^2)

# Process a list of data frames in parallel, one per ticker
tickers <- list(AAPL = df_aapl, MSFT = df_msft, GOOG = df_goog)
results <- iaw$mclapply(tickers, function(d) lm(ret ~ mkt, data = d))

# Use stop.on.error = FALSE to collect partial results despite failures
out <- iaw$mclapply(1:5, function(x) {
  if (x == 3) stop("bad element")
  x^2
}, stop.on.error = FALSE)
}
}
