% Generated by tools/generate-man.R -- do not edit by hand
\name{rbind.mc.by}
\alias{rbind.mc.by}
\title{Rbind Results from mc.by}
\description{
Combines mc.by results into data frame.
}
\usage{
rbind.mc.by(indata, INDICES, FUNIN, ...)
}
\arguments{
  \item{indata}{Data frame.}
  \item{INDICES}{Grouping variable.}
  \item{FUNIN}{Function returning data frames.}
  \item{...}{Additional arguments. }
}
\value{
Combined data frame. 
}
\seealso{

Other parallel: \code{\link{mc.by}}, \code{\link{mc.replicate}}, \code{\link{mclapply}}, \code{\link{mcsapply}}, \code{\link{oc.by}}, \code{\link{rbind.oc.by}}
}
\examples{
\dontrun{
# Demean x within each group and return all rows combined
df <- data.frame(
  group = c("A", "A", "B", "B", "B"),
  x     = c(1, 3, 2, 4, 6)
)
result <- iaw$rbind.mc.by(df, df$group, function(sub) {
  sub$x_dm <- sub$x - mean(sub$x)
  sub
})
result  # all rows combined into one data frame, preserving columns

# Compute rolling z-scores within each sector (parallel)
stocks <- data.frame(
  sector = rep(c("Tech", "Fin"), each = 4),
  ret    = c(0.01, 0.03, -0.02, 0.05, 0.02, -0.01, 0.01, 0.04)
)
result <- iaw$rbind.mc.by(stocks, stocks$sector, function(sub) {
  sub$z <- scale(sub$ret)
  sub
})
result  # 8-row data frame with z-score column added

# Filter within groups in parallel, then combine survivors
result <- iaw$rbind.mc.by(stocks, stocks$sector, function(sub) {
  sub[sub$ret > median(sub$ret), ]
})
nrow(result)  # only rows above within-group median
}

}
