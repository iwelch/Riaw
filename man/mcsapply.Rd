% Generated by tools/generate-man.R -- do not edit by hand
\name{mcsapply}
\alias{mcsapply}
\alias{mc.sapply}
\title{Enhanced Multicore Sapply}
\description{
Wrapper for mclapply with simplification.
}
\usage{
mcsapply(X, FUN, ...)
}
\arguments{
  \item{X}{List or vector.}
  \item{FUN}{Function to apply.}
  \item{...}{Arguments to FUN. }
}
\value{
Simplified result. 
}
\seealso{

Other parallel: \code{\link{mc.by}}, \code{\link{mc.replicate}}, \code{\link{mclapply}}, \code{\link{oc.by}}, \code{\link{rbind.mc.by}}, \code{\link{rbind.oc.by}}
}
\examples{
\dontrun{
# Returns a numeric vector (like sapply) rather than a list
iaw$mcsapply(1:10, function(x) x^2)

# Compute summary stats across many simulations, returning a matrix
stats <- iaw$mcsapply(1:100, function(i) {
  x <- rnorm(50)
  c(mean = mean(x), sd = sd(x))
})
dim(stats)   # 2 x 100 matrix; rowMeans(stats) gives grand mean and sd

# Apply a function across column names of a data frame
df <- data.frame(a = rnorm(30), b = rnorm(30), c = rnorm(30))
iaw$mcsapply(names(df), function(col) mean(df[[col]]))

# Parallel column-wise standard deviations
mat <- matrix(rnorm(300), ncol = 10)
iaw$mcsapply(1:ncol(mat), function(j) sd(mat[, j]))

# Estimate multiple sample quantiles in parallel
data_list <- list(a = rnorm(1000), b = rexp(1000), c = runif(1000))
medians <- iaw$mcsapply(data_list, median)
medians  # named numeric vector: a ~ 0, b ~ 0.69, c ~ 0.5
}
}
